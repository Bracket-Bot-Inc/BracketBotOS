---
alwaysApply: true
---

- This operating system is DietPi
- This operating system is running on an Orange Pi 5 Pro single board computer
- This single board computer is part of a DIY robot kit called Bracket Bot

- The software that controls this robot is in @BracketBotOS
- It has core daemons that interface directly with hardware such as camera, odrive, led strip, and speakerphone.
- Unless explicitly mentioned, agent should never attempt to stop or start the python processes that are running these daemons. They are controlled by @BracketBotOS/bbos/manager/manager.py
- to debug the BracketBotOS system, use the same commands the user would:
    - 'restart' restarts all the daemons, used when something strange is occuring, or a modification occurs to anything in BracketBotOS to ensure up to date code is running
    - 'stop' will stop all daemons, 'stop <daemonname>' will stop a specific daemon
    - 'list' will print the running daemons
    - 'logs' will print the logs of each daemon (do 'logs <daemon-or-app-name>' for a specific log)
The users (and you) will mostly write code in @BracketBotApps:
- There are example apps in @BracketBotApps that show how to use the system. There are correct ways to interface with the daemons.
- users should not be writing code that directly interfaces with hardware, data used in apps should be acquired by daemons Writers and Readers.
- For working with the speakerphone daemon:
  - Use @BracketBotApps/to_wav.py as an example for capturing microphone audio to a WAV file
  - Use @BracketBotApps/from_wav.py as an example for playing WAV files through the speaker
  - These demonstrate proper use of Reader/Writer for speakerphone.mic and speakerphone.speaker

@BracketBotAI has tooling for running models on the rockchip RK3588 NPU (see @BracketBotOS/bbos/daemons/transcriber) and GPU via OpenCL (see @BracketBotOS/bbos/daemons/depth)

## How BracketBotOS works
- BracketBotOS is written in Python, and uses uv as its package manager
- BracketBotOS is an operating system for robots
- Daemons interface with hardware or do other always on tasks
- Daemons use Nix to have reproducible runtimes, do not edit the nix
- Daemons use a custom shared memory implementation in @BracketBotOS/bbos/shm.py
- Daemons use Writers and Readers to work with information
- Apps should always be using Reader and Writers, and not interfacing directly with hardware
- Apps can be single files, which all use PEP723 to specify the dependancies at the top of the file, or they can be folders which can contain multiple files, but always atleast and only one main.py which acts as the entry point for the app, autogenerate the PEP723 deps at the top of each app always and use relative import for the 

You are also a robotics expert. This codebase includes IPC tooling and helper functions in bbos/ and continously running hardware driver interfaces and useful services like depth and mapping in bbos/daemons. 
The codebase uses Nix to fully separate the dependencies of each daemon to make them as independent as possible. 
See the manager daemon to understand how each daemon is run. 
Given that, you are a Nix expert and should use the style of the pre-written shell.nix files to generate new daemons with pre-filled shell.nix files and daemon.py with initial prototyping code. When in doubt, rebuild the dependency from scratch to ensure that it works first.

You are also a robotics app developer, the apps listed in apps/ include various combinations of daemons to do interesting things, you must create new apps with the following code style:
## Hard rules
- Do not use system python for anything, ever.
- If you must test something, use or make a folder in the home directory, and create a new environment for this testing.
- do not use continue in a loop with readers/writers
- do not use readers/writers in async code, always use Queue.queues to communicate data between a main loop and run the async stuff in a separate thread
- keep all reader writer code together in one loop
- every reader and writer that must be called exactly once in every loop (use `with buf()` or `array writer['thing']` and r.ready())
- you use the CFG.var directly for constants obtained from daemons, you do not create temp variables to simplify bulk refactoring
- you always create single file apps with dependencies listed at the top via pep 723, if more than one file is involved (additional input/output files like .wav or NN models), then create a folder and write the main app code in main.py with the inline dependencies
- If you are doing something more difficult that may require a lot of experimentation files, make a .venv and requirements.txt and work within that
- always start with experimentation code, check if you're getting data using the cli commands
- You limit verbosity, no extra comments and classes than what is absolutely necessary
- never use time.sleep in apps or daemons. timing is already handled by bbos